/**
 * Enhanced Network Performance Measurement Tool
 * 
 * This program can function as either a server or a client for comprehensive network performance testing.
 * It measures one-way latency, round-trip time (RTT), jitter, and packet loss between network endpoints.
 * 
 * AIX Compatibility:
 * Compile with: gcc -O2 -std=gnu99 -D_ALL_SOURCE -o netperf combined-latency-jitter.c -lm
 * 
 * Usage:
 *   Server mode: ./netperf -s [-p port] [-u] [-6]
 *   Client mode: ./netperf -c server_ip [-p port] [-u] [-n num_packets] [-d delay_ms] [-l packet_size] 
 *                          [-r rate] [-o output_file] [-6] [-t]
 */

/* Define AIX compatibility features */
#define _ALL_SOURCE

/* Order of includes is important for AIX with GCC to avoid conflicts */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <stdint.h>

/* AIX-specific includes */
#ifdef _AIX
#include <sys/machine.h>  /* For byte-order functions specific to AIX */
#endif

/* Network includes */
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

/* Additional includes */
#include <time.h>
#include <math.h>
#include <signal.h>
#include <fcntl.h>

// Default parameters
#define DEFAULT_PORT 8888
#define DEFAULT_NUM_PACKETS 100
#define DEFAULT_DELAY_MS 100
#define MIN_PACKET_SIZE 64
#define DEFAULT_PACKET_SIZE 1024
#define MAX_PACKET_SIZE 8192
#define DEFAULT_RATE_PPS 10  // packets per second

// Protocol settings
#define PROTOCOL_TCP 0
#define PROTOCOL_UDP 1

// Global variables for signal handling
int running = 1;
int server_socket = -1;

// Packet structure with variable payload size
typedef struct {
    uint64_t seq_num;        // Sequence number for packet loss detection
    uint64_t client_send;    // Timestamp when client sent the packet
    uint64_t server_recv;    // Timestamp when server received the packet
    uint64_t server_send;    // Timestamp when server sent response
    uint64_t client_recv;    // Timestamp when client received response
    uint32_t packet_size;    // Size of this packet in bytes
    uint8_t payload[];       // Variable-sized payload (C99 flexible array member)
} packet_t;

// Test configuration structure
typedef struct config_t {
    int is_server;
    char server_ip[128];     // Support for IPv6 addresses
    int port;
    int protocol;            // TCP or UDP
    int use_ipv6;            // IPv4 or IPv6
    int num_packets;
    int delay_ms;
    int packet_size;
    int rate_pps;            // Packets per second
    int time_sync;           // Whether to use time synchronization
    char output_file[256];
} config_t;

// Forward declarations (after structures are defined)
int init_socket_address(struct sockaddr_storage* addr, const char* host, int port, int use_ipv6);
packet_t* create_packet(int packet_size);
int validate_packet(packet_t* packet);
int64_t synchronize_clocks(int socket_fd, int is_client, int protocol);
void run_tcp_server(config_t* config);
void run_udp_server(config_t* config);
void run_tcp_client(config_t* config);
void run_udp_client(config_t* config);

/**
 * Get current timestamp in microseconds with highest available precision
 */
uint64_t get_timestamp_usec() {
    /* Use gettimeofday for AIX and other systems for better compatibility */
    struct timeval tv;
    gettimeofday(&tv, NULL);
    return (uint64_t)(tv.tv_sec * 1000000 + tv.tv_usec);
}

/**
 * Signal handler for graceful termination
 */
void handle_signal(int sig) {
    printf("\nReceived signal %d, shutting down...\n", sig);
    running = 0;
    if (server_socket >= 0) {
        close(server_socket);
    }
}

/**
 * Display usage information
 */
void print_usage(const char* prog_name) {
    printf("Usage:\n");
    printf("  Server mode: %s -s [-p port] [-u] [-6]\n", prog_name);
    printf("  Client mode: %s -c server_ip [-p port] [-u] [-n num_packets] [-d delay_ms]\n", prog_name);
    printf("                            [-l packet_size] [-r rate] [-o output_file] [-6] [-t]\n\n");
    printf("Options:\n");
    printf("  -s                Run in server mode\n");
    printf("  -c server_ip      Run in client mode, connecting to server_ip\n");
    printf("  -p port           Port to use (default: %d)\n", DEFAULT_PORT);
    printf("  -u                Use UDP instead of TCP\n");
    printf("  -n num_packets    Number of test packets to send (default: %d)\n", DEFAULT_NUM_PACKETS);
    printf("  -d delay_ms       Delay between packets in ms (default: %d)\n", DEFAULT_DELAY_MS);
    printf("  -l packet_size    Size of each packet in bytes (default: %d, min: %d, max: %d)\n", 
           DEFAULT_PACKET_SIZE, MIN_PACKET_SIZE, MAX_PACKET_SIZE);
    printf("  -r rate           Sending rate in packets per second (default: %d)\n", DEFAULT_RATE_PPS);
    printf("  -o output_file    Write results to CSV file\n");
    printf("  -6                Use IPv6 instead of IPv4\n");
    printf("  -t                Enable clock synchronization attempt\n");
    printf("  -h                Display this help message\n");
}

/**
 * Create and allocate a packet with the specified size
 */
packet_t* create_packet(int packet_size) {
    if (packet_size < sizeof(packet_t)) {
        packet_size = sizeof(packet_t);
    }
    
    // Allocate with enough space for the payload
    packet_t* packet = (packet_t*)malloc(packet_size);
    if (packet == NULL) {
        perror("Memory allocation failed");
        exit(EXIT_FAILURE);
    }
    
    memset(packet, 0, packet_size);
    packet->packet_size = packet_size;
    
    // Fill payload with a recognizable pattern
    for (int i = 0; i < packet_size - sizeof(packet_t); i++) {
        packet->payload[i] = (i % 256);
    }
    
    return packet;
}

/**
 * Validate packet integrity (check payload)
 */
int validate_packet(packet_t* packet) {
    if (packet == NULL || packet->packet_size < sizeof(packet_t)) {
        return 0;
    }
    
    // Check payload integrity
    for (int i = 0; i < packet->packet_size - sizeof(packet_t); i++) {
        if (packet->payload[i] != (i % 256)) {
            return 0;
        }
    }
    
    return 1;
}

/**
 * Initialize socket address structure (works with both IPv4 and IPv6)
 */
int init_socket_address(struct sockaddr_storage* addr, const char* host, int port, int use_ipv6) {
    memset(addr, 0, sizeof(struct sockaddr_storage));
    
    if (use_ipv6) {
        struct sockaddr_in6* addr6 = (struct sockaddr_in6*)addr;
        addr6->sin6_family = AF_INET6;
        addr6->sin6_port = htons(port);
        
        if (host == NULL) {
            // Server mode, bind to any address
            addr6->sin6_addr = in6addr_any;
        } else {
            // Client mode, connect to specific host
            if (inet_pton(AF_INET6, host, &addr6->sin6_addr) <= 0) {
                perror("Invalid IPv6 address format");
                return -1;
            }
        }
        return sizeof(struct sockaddr_in6);
    } else {
        struct sockaddr_in* addr4 = (struct sockaddr_in*)addr;
        addr4->sin_family = AF_INET;
        addr4->sin_port = htons(port);
        
        if (host == NULL) {
            // Server mode, bind to any address
            addr4->sin_addr.s_addr = INADDR_ANY;
        } else {
            // Client mode, connect to specific host
            if (inet_pton(AF_INET, host, &addr4->sin_addr) <= 0) {
                perror("Invalid IPv4 address format");
                return -1;
            }
        }
        return sizeof(struct sockaddr_in);
    }
}

/**
 * Attempt to synchronize clocks between client and server
 * This is a simplified approach inspired by PTP (Precision Time Protocol)
 */
int64_t synchronize_clocks(int socket_fd, int is_client, int protocol) {
    if (!is_client) {
        return 0; // Server doesn't adjust time
    }
    
    const int SYNC_ROUNDS = 10;
    int64_t offsets[SYNC_ROUNDS];
    int64_t min_rtt = INT64_MAX;
    int best_round = 0;
    
    printf("Attempting clock synchronization with server...\n");
    
    for (int i = 0; i < SYNC_ROUNDS; i++) {
        uint64_t t1, t2, t3, t4;
        packet_t sync_packet;
        
        // Prepare sync packet
        memset(&sync_packet, 0, sizeof(packet_t));
        sync_packet.seq_num = 0xFFFFFFFF - i; // Special sequence for sync packets
        sync_packet.packet_size = sizeof(packet_t);
        
        // t1: Client send time
        t1 = get_timestamp_usec();
        sync_packet.client_send = t1;
        
        // Send to server
        if (protocol == PROTOCOL_TCP) {
            if (send(socket_fd, &sync_packet, sizeof(packet_t), 0) < 0) {
                perror("Sync send failed");
                continue;
            }
            
            if (recv(socket_fd, &sync_packet, sizeof(packet_t), 0) <= 0) {
                perror("Sync recv failed");
                continue;
            }
        } else {
            struct sockaddr_storage server_addr;
            socklen_t addr_len = sizeof(server_addr);
            
            if (sendto(socket_fd, &sync_packet, sizeof(packet_t), 0, 
                      (struct sockaddr*)&server_addr, addr_len) < 0) {
                perror("Sync UDP send failed");
                continue;
            }
                  
            if (recvfrom(socket_fd, &sync_packet, sizeof(packet_t), 0,
                        (struct sockaddr*)&server_addr, &addr_len) <= 0) {
                perror("Sync UDP recv failed");
                continue;
            }
        }
        
        // t4: Client receive time
        t4 = get_timestamp_usec();
        
        // Extract t2 and t3 from packet
        t2 = sync_packet.server_recv;
        t3 = sync_packet.server_send;
        
        // Calculate RTT and offset
        int64_t rtt = (t4 - t1) - (t3 - t2);
        int64_t offset = ((t2 - t1) + (t3 - t4)) / 2;
        
        offsets[i] = offset;
        
        // Keep track of the round with minimum RTT
        if (rtt < min_rtt) {
            min_rtt = rtt;
            best_round = i;
        }
        
        // Small delay between sync rounds
        usleep(50000); // 50ms
    }
    
    int64_t best_offset = offsets[best_round];
    printf("Clock synchronization complete. Estimated offset: %ld μs (%.2f ms)\n", 
           best_offset, best_offset / 1000.0);
    
    return best_offset;
}

/**
 * Server implementation - TCP protocol
 */
void run_tcp_server(config_t* config) {
    int server_fd, client_fd;
    struct sockaddr_storage address;
    int opt = 1;
    socklen_t addrlen = sizeof(address);
    packet_t* packet_buffer;
    
    // Allocate packet buffer for maximum possible size
    packet_buffer = create_packet(MAX_PACKET_SIZE);
    
    // Create socket
    server_fd = socket(config->use_ipv6 ? AF_INET6 : AF_INET, SOCK_STREAM, 0);
    if (server_fd < 0) {
        perror("Socket creation failed");
        free(packet_buffer);
        exit(EXIT_FAILURE);
    }
    
    // Set socket options
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) < 0) {
        perror("setsockopt failed");
        free(packet_buffer);
        close(server_fd);
        exit(EXIT_FAILURE);
    }
    
    // Setup address structure
    int addr_size = init_socket_address(&address, NULL, config->port, config->use_ipv6);
    if (addr_size < 0) {
        close(server_fd);
        free(packet_buffer);
        exit(EXIT_FAILURE);
    }
    
    // Bind socket
    if (bind(server_fd, (struct sockaddr*)&address, addr_size) < 0) {
        perror("Bind failed");
        close(server_fd);
        free(packet_buffer);
        exit(EXIT_FAILURE);
    }
    
    // Listen for connections
    if (listen(server_fd, 5) < 0) {
        perror("Listen failed");
        close(server_fd);
        free(packet_buffer);
        exit(EXIT_FAILURE);
    }
    
    server_socket = server_fd;  // For signal handler
    printf("TCP server started. Listening on %s port %d...\n", 
           config->use_ipv6 ? "IPv6" : "IPv4", config->port);
    
    while (running) {
        // Accept connection
        client_fd = accept(server_fd, (struct sockaddr*)&address, &addrlen);
        if (client_fd < 0) {
            if (running) {  // Only show error if we're still supposed to be running
                perror("Accept failed");
            }
            break;
        }
        
        // Get client address information
        char client_str[INET6_ADDRSTRLEN];
        int client_port = 0;
        
        if (address.ss_family == AF_INET6) {
            struct sockaddr_in6* addr6 = (struct sockaddr_in6*)&address;
            inet_ntop(AF_INET6, &addr6->sin6_addr, client_str, sizeof(client_str));
            client_port = ntohs(addr6->sin6_port);
        } else {
            struct sockaddr_in* addr4 = (struct sockaddr_in*)&address;
            inet_ntop(AF_INET, &addr4->sin_addr, client_str, sizeof(client_str));
            client_port = ntohs(addr4->sin_port);
        }
        
        printf("TCP connection accepted from [%s]:%d\n", client_str, client_port);
        
        // Process incoming packets
        uint64_t packet_count = 0;
        while (running) {
            // Receive packet header first to determine size
            int bytes_received = recv(client_fd, packet_buffer, sizeof(packet_t), 0);
            if (bytes_received <= 0) {
                break;
            }
            
            // Handle synchronization packets
            if (packet_buffer->seq_num >= 0xFFFFFFFF - 20) {
                // This is a sync packet, just timestamp and return
                packet_buffer->server_recv = get_timestamp_usec();
                packet_buffer->server_send = get_timestamp_usec();
                send(client_fd, packet_buffer, sizeof(packet_t), 0);
                continue;
            }
            
            // Then receive the rest of the packet if needed
            int remaining_bytes = packet_buffer->packet_size - bytes_received;
            if (remaining_bytes > 0) {
                bytes_received += recv(client_fd, ((char*)packet_buffer) + bytes_received, 
                                      remaining_bytes, 0);
            }
            
            if (bytes_received <= 0) {
                printf("Client disconnected after %lu packets\n", packet_count);
                break;
            }
            
            // Update server timestamps
            packet_buffer->server_recv = get_timestamp_usec();
            packet_buffer->server_send = get_timestamp_usec();
            
            // Send packet back to client
            send(client_fd, packet_buffer, packet_buffer->packet_size, 0);
            packet_count++;
        }
        
        // Close client socket
        close(client_fd);
    }
    
    // Clean up
    close(server_fd);
    free(packet_buffer);
    printf("TCP server shutdown complete\n");
}

/**
 * Server implementation - UDP protocol
 */
void run_udp_server(config_t* config) {
    int server_fd;
    struct sockaddr_storage client_addr;
    socklen_t addr_len = sizeof(client_addr);
    packet_t* packet_buffer;
    
    // Allocate packet buffer for maximum possible size
    packet_buffer = create_packet(MAX_PACKET_SIZE);
    
    // Create socket
    server_fd = socket(config->use_ipv6 ? AF_INET6 : AF_INET, SOCK_DGRAM, 0);
    if (server_fd < 0) {
        perror("Socket creation failed");
        free(packet_buffer);
        exit(EXIT_FAILURE);
    }
    
    // Setup address structure
    struct sockaddr_storage server_addr;
    int addr_size = init_socket_address(&server_addr, NULL, config->port, config->use_ipv6);
    if (addr_size < 0) {
        close(server_fd);
        free(packet_buffer);
        exit(EXIT_FAILURE);
    }
    
    // Bind socket
    if (bind(server_fd, (struct sockaddr*)&server_addr, addr_size) < 0) {
        perror("Bind failed");
        close(server_fd);
        free(packet_buffer);
        exit(EXIT_FAILURE);
    }
    
    server_socket = server_fd;  // For signal handler
    printf("UDP server started. Listening on %s port %d...\n", 
           config->use_ipv6 ? "IPv6" : "IPv4", config->port);
    
    // Process incoming datagrams
    while (running) {
        addr_len = sizeof(client_addr);
        
        // Receive datagram
        int bytes_received = recvfrom(server_fd, packet_buffer, MAX_
